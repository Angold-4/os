<!DOCTYPE html>
<html lang="en"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">
<head>
    <title>Angold-4 Organization</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../../images/favicon.png" rel="icon">

<link rel="canonical" href=".">
        <meta name="author" content="Angold Wang" />

    <meta property="og:site_name" content="Angold-4" />
<!--     <meta property="og:type" content="article"/> -->
    <meta property="og:title" content="Angold-4 Organization"/>
    <meta property="og:url" content="."/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="../../../theme/css/bootstrap.flatly.min.css" type="text/css"/>
    <link href="../../../theme/css/font-awesome.min.css" rel="stylesheet">
<!--     <link href="https://cdnjs.cloudflare.com/ajax/libs/typicons/2.0.9/typicons.min.css" rel="stylesheet"> -->

    <link href="../../../theme/css/pygments/monokai.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../theme/css/style.css" type="text/css"/>

</head>
<body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!-- <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script> -->

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://angold4.org" class="navbar-brand">
<img src="../../../images/logo.png" width="32"/> Angold4            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
			    <li><a href="../../../about.html">About</a>
                            <li><a href="../../../blogs.html">Blogs</a>
                            <li><a href="../../../projects.html">Projects</a>

	    </ul>
            <ul class="nav navbar-nav navbar-right">
                <li> <a title="Youtube" href="https://www.youtube.com/channel/UC3ZAjh2LHhm-FrgxgBtgMzQ" target="_new"><i class="fa fa-youtube"></i> Youtube</a>
		</li>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->


<div class="container">
    <div class="row">
        <div class="col-lg-12">
	<section id="content" class="body">



<h1>3. Special Topic: Traps</h1>
<h5>03/06/2022 By Angold Wang</h5>
<p>There are three kinds of event which cause the CPU to set aside ordinary execution of instructions and force a transfer of control to special code that handles the event:</p>
<ol>
<li><strong>System Call:</strong> When a user program executes the <strong><code>ecall</code></strong> instruction to ask the kernel to do something for it.</li>
<li><strong>Exception:</strong> When an instruction (user/kernel) does something illegal, such as divide by zero or use an invalid virtual address, or page fault.</li>
<li><strong>Interrupt:</strong> When a device signals that it needs attention.</li>
</ol>
<p><strong>Trap is a generic term for these situations.</strong>
Typically, whatever code was executing at the time of the trap will later need to resume, and shouldn't need to be aware that anything special happends.</p>
<p><strong>In this topic, we'll step into the actual <code>xv6</code> code and check the details of how traps were implemented by walking through a whole <code>SYS_write</code> system call procedule when we booting the <code>xv6</code>.</strong></p>
<h2>0. Boot xv6</h2>
<p>When the RISC-V computer powers on. It initializes itself and runs a boot loader which is stored in read-only memory. The boot loader loads the xv6 kernel into memory.</p>
<p>The loader loads the xv6 kernel into memory at physical address <strong><code>0x80000000</code></strong>. The reason it places the kernel at <strong><code>0x80000000</code></strong> rather than <strong><code>0x0</code></strong> is because the address range <strong><code>0x0:0x80000000</code></strong> contains I/O devices.</p>
<p><img src="Sources/addressxv6.png" alt="addressxv6"></p>
<h3>i. <code>_entry</code></h3>
<p>Then in <strong>machine mode</strong>. The CPU executes xv6 starting at <code>_entry</code> <strong>(kernel/entry.s)</strong></p>
<pre><code class="language-asm">    # qemu -kernel loads the kernel at 0x80000000
    # and causes each CPU to jump there.
    # kernel.ld causes the following code to
    # be placed at 0x80000000.
.section .text
.global _entry
_entry:
	# set up a stack for C.
        # stack0 is declared in start.c,
        # with a 4096-byte stack per CPU.
        # sp = stack0 + (hartid * 4096)
        la sp, stack0
        li a0, 1024*4
        csrr a1, mhartid
        addi a1, a1, 1
        mul a0, a0, a1
        add sp, sp, a0
	# jump to start() in start.c
        call start
spin:
        j spin

</code></pre>
<p><strong>Basically, this piece of code does two things:</strong></p>
<ol>
<li><strong>Set up a stack so that xv6 can run C code. and set the stack pointer <code>%sp</code> with the address <code>stack0 + 4096</code>.</strong>
<ul>
<li>Set the stack in order to let xv6 run C code</li>
<li>The <code>stack0</code> is defined in <code>kernel/start.c</code>, which is the initial stack of xv6.</li>
</ul>
</li>
<li><strong>Then calls into C code at <code>start</code> at <code>kernel/start.c</code></strong></li>
</ol>
<h3>ii. <code>start</code></h3>
<pre><code class="language-c">// entry.S jumps here in machine mode on stack0.
void
start()
{
  // set M Previous Privilege mode to Supervisor, for mret.
  unsigned long x = r_mstatus();
  x &amp;= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);

  // set M Exception Program Counter to main, for mret.
  // requires gcc -mcmodel=medany
  w_mepc((uint64)main);

  // disable paging for now.
  w_satp(0);

  // delegate all interrupts and exceptions to supervisor mode.
  w_medeleg(0xffff);
  w_mideleg(0xffff);
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

  // configure Physical Memory Protection to give supervisor mode
  // access to all of physical memory.
  w_pmpaddr0(0x3fffffffffffffull);
  w_pmpcfg0(0xf);

  // ask for clock interrupts.
  timerinit();

  // keep each CPU's hartid in its tp register, for cpuid().
  int id = r_mhartid();
  w_tp(id);

  // switch to supervisor mode and jump to main().
  asm volatile(&quot;mret&quot;);
}
</code></pre>
<p><strong>Machine Mode vs. Supervisor Mode</strong>: Machine mode has access to all the hardware features but does not have virtual-memory support.</p>
<ol>
<li><strong>Writing <code>main</code>'s address into register <code>%mepc</code> in order to return to <code>main</code> after <code>start</code> finished</strong></li>
<li><strong>Writing <code>0</code> into the page-table register <code>satp</code> in order to disables virtual address translation</strong> (we haven't set the page table yet).</li>
<li>Program the clock chip to generate clock interrupt (0.1s).</li>
</ol>
<p>Although we haven't set any page table yet (even for kernel page table), we still can access some physical memory. The reason is that &quot;<strong>Identical Mapping</strong>&quot; in xv6, which  <strong>mapping the resources at virtual address between <code>0x80000000</code> to <code>0x86400000</code> that are equal to the physical address.</strong></p>
<h3>iii. <code>main</code></h3>
<pre><code class="language-c">// start() jumps here in supervisor mode on all CPUs.
void
main()
{
  if(cpuid() == 0){
    consoleinit();
    printfinit();
    printf(&quot;\n&quot;);
    printf(&quot;xv6 kernel is booting\n&quot;);
    printf(&quot;\n&quot;);
    kinit();         // physical page allocator
    kvminit();       // create kernel page table
    kvminithart();   // turn on paging
    procinit();      // process table
    trapinit();      // trap vectors
    trapinithart();  // install kernel trap vector
    plicinit();      // set up interrupt controller
    plicinithart();  // ask PLIC for device interrupts
    binit();         // buffer cache
    iinit();         // inode table
    fileinit();      // file table
    virtio_disk_init(); // emulated hard disk
    userinit();      // first user process
    __sync_synchronize();
    started = 1;
  } else {
    while(started == 0)
      ;
    __sync_synchronize();
    printf(&quot;hart %d starting\n&quot;, cpuid());
    kvminithart();    // turn on paging
    trapinithart();   // install kernel trap vector
    plicinithart();   // ask PLIC for device interrupts
  }

  scheduler();        
}
</code></pre>
<p><strong>This is the <code>main()</code> boot sequence of xv6, We are going to only introduce two procedures since we only mentioned these two concepts before.</strong></p>
<ul>
<li><strong><code>kvminit()</code> for initializing kernel page table</strong></li>
<li><strong><code>userinit()</code> for making the first user system call</strong></li>
</ul>
<h3>iv. <code>main</code> -- <code>kvminit()</code></h3>
<pre><code class="language-c">// Initialize the one kernel_pagetable
void
kvminit(void)
{
  kernel_pagetable = kvmmake();
}
</code></pre>
<p><strong><code>main</code> calls <code>kvminit</code> to create the kernel's page table using <code>kvmmake</code>, this call occurs before xv6 has enabled paging on the RISC-V, so the address refer directly to physical memory.</strong></p>
<pre><code class="language-c">// Make a direct-map page table for the kernel.
pagetable_t
kvmmake(void)
{
  pagetable_t kpgtbl;

  kpgtbl = (pagetable_t) kalloc();
  memset(kpgtbl, 0, PGSIZE);

  // uart registers
  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

  // virtio mmio disk interface
  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);

  // PLIC
  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

  // map kernel text executable and read-only.
  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

  // map kernel data and the physical RAM we'll make use of.
  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

  // map the trampoline for trap entry/exit to
  // the highest virtual address in the kernel.
  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

  // map kernel stacks
  proc_mapstacks(kpgtbl);
  
  return kpgtbl;
}

</code></pre>
<ol>
<li><strong><code>kvmmake</code> first allocates a page of physical memory to hold the root page-table page.</strong></li>
<li><strong>Then it calls <code>kvmmap</code> to install the translations(page tables) that the kernel needs:</strong>
<ul>
<li>kernel's instructions and data.</li>
<li>physical memory up to <code>PHYSTOP</code></li>
<li>memory ranges which are actually devices</li>
</ul>
</li>
<li><strong>Finially it calls <code>proc_mapstacks</code> in order to allocate a kernel stack for each process.</strong></li>
</ol>
<ul>
<li>After all these mappings are done, the kernel's page table should looks like this:</li>
</ul>
<pre><code>(qemu) info mem
vaddr            paddr            size             attr
---------------- ---------------- ---------------- -------
000000000c000000 000000000c000000 0000000000400000 rw-----
0000000010000000 0000000010000000 0000000000002000 rw-----
0000000080000000 0000000080000000 0000000000001000 r-x--a-
0000000080001000 0000000080001000 0000000000007000 r-x----
0000000080008000 0000000080008000 0000000000017000 rw-----
000000008001f000 000000008001f000 0000000000001000 rw---a-
0000000080020000 0000000080020000 0000000007fe0000 rw-----
0000003ffff7f000 0000000087f78000 0000000000040000 rw-----
0000003ffffff000 0000000080007000 0000000000001000 r-x----

</code></pre>
<pre><code class="language-c">// add a mapping to the kernel page table.
// only used when booting.
// does not flush TLB or enable paging.
void
kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
{
  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
    panic(&quot;kvmmap&quot;);
}

// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned. Returns 0 on success, -1 if walk() couldn't
// allocate a needed page-table page.
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
{
  uint64 a, last;
  pte_t *pte;

  if(size == 0)
    panic(&quot;mappages: size&quot;);
  
  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
    if((pte = walk(pagetable, a, 1)) == 0)
      return -1;
    if(*pte &amp; PTE_V)
      panic(&quot;mappages: remap&quot;);
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
</code></pre>
<p><strong><code>kvmmap</code> calls <code>mappages</code>, which installs mappings into a page table for a range of virtual addresses to a corresponding range of physical addresses.</strong> It does this seperately for each virtual address in the range, at page intervals. For each virtual address to be mapped, <strong><code>mappages</code></strong> calls <strong><code>walk</code></strong> to find the address of the PTE for that address. It then initializes the PTE to hold the relevant physical page number, and set its desired permissions.</p>
<p><strong>Basically, what the <code>mappages</code> does is that it creates many page tables by calling <code>walk</code>, in order to map <code>size</code> of memory from virtual address <code>va</code> to physical address <code>pa</code>.</strong></p>
<pre><code class="language-c">// Return the address of the PTE in page table pagetable
// that corresponds to virtual address va.  If alloc!=0,
// create any required page-table pages.
//
// The risc-v Sv39 scheme has three levels of page-table
// pages. A page-table page contains 512 64-bit PTEs.
// A 64-bit virtual address is split into five fields:
//   39..63 -- must be zero.
//   30..38 -- 9 bits of level-2 index.
//   21..29 -- 9 bits of level-1 index.
//   12..20 -- 9 bits of level-0 index.
//    0..11 -- 12 bits of byte offset within the page.
pte_t *
walk(pagetable_t pagetable, uint64 va, int alloc)
{
  if(va &gt;= MAXVA)
    panic(&quot;walk&quot;);

  for(int level = 2; level &gt; 0; level--) {
    // 
    // PX extract the three 9-bit page table indices from a virtual address.
    pte_t *pte = &amp;pagetable[PX(level, va)];
    if(*pte &amp; PTE_V) { // valid or not
      pagetable = (pagetable_t)PTE2PA(*pte);
    } else {
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
        return 0;
      memset(pagetable, 0, PGSIZE);
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &amp;pagetable[PX(0, va)]; // the new page table
}
</code></pre>
<p><strong>Finally comes to <code>walk</code>, this function mimics the RISC-V paging hardware as it looks up the PTE for a virtual address.</strong></p>
<ol>
<li><strong><code>walk</code></strong> descends the 3-level page table 9 bits at the time. It uses each level's 9 bits of virtual address to find the PTE of either the next-level page table or the final page table.</li>
<li>If the PTE isn't valid, then the required page hasn't yet been allocated; if the <code>alloc</code> argument is set, <strong><code>walk</code></strong> allocates a new page-table page and puts its physical address in the PTE.</li>
<li>Finally, it returns the address of the PTE in the lowest layer in the tree.</li>
</ol>
<p>After all page tables of kernel has been created successfully, <strong><code>main</code></strong> calls <strong><code>kvminithart</code></strong>, which install this kernel page table by writing the physical address of the root page table page into the register <code>satp</code>, and then allow CPU translate addresses using the kernel page table.</p>
<pre><code class="language-c">// Switch h/w page table register to the kernel's page table,
// and enable paging.
void
kvminithart()
{
  w_satp(MAKE_SATP(kernel_pagetable));
  sfence_vma();
}

</code></pre>
<h3>v. <code>main</code> -- <code>userinit()</code></h3>
<p><strong>After <code>main</code> initializes several devices, subsystems and memory, it create the first user process by calling <code>userinit</code>.</strong></p>
<pre><code class="language-c">// a user program that calls exec(&quot;/init&quot;)
// od -t xC initcode
uchar initcode[] = {
  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};


// Set up first user process.
void
userinit(void)
{
  struct proc *p;

  // Look in the process table for an UNUSED proc.
  p = allocproc(); // total 64 process, 
  initproc = p;
  
  // allocate one user page and copy init's instructions
  // and data into it.
  uvminit(p-&gt;pagetable, initcode, sizeof(initcode));
  p-&gt;sz = PGSIZE;

  // prepare for the very first &quot;return&quot; from kernel to user.
  p-&gt;trapframe-&gt;epc = 0;      // user program counter
  p-&gt;trapframe-&gt;sp = PGSIZE;  // user stack pointer

  safestrcpy(p-&gt;name, &quot;initcode&quot;, sizeof(p-&gt;name));
  p-&gt;cwd = namei(&quot;/&quot;);

  p-&gt;state = RUNNABLE;

  release(&amp;p-&gt;lock);
}
</code></pre>
<p><strong><code>userinit</code> basically does these things:</strong></p>
<ol>
<li>It look in the process table for an unused proc by calling <strong><code>allocproc</code></strong></li>
<li>Call <strong><code>uvminit</code></strong> to set the user virtual memory, and load the <code>initcode</code> into the new process's page table in order to exec.</li>
<li>Set the first user process's state to <code>RUNNABLE</code>, which means it will assigned to be executed by process scheduler.</li>
</ol>
<pre><code class="language-assembly"># initcode.s
# Initial process that execs /init.
# This code runs in user space.

#include &quot;syscall.h&quot;

# exec(init, argv)
.globl start
start:
        la a0, init
        la a1, argv
        li a7, SYS_exec
        ecall

# for(;;) exit();
exit:
        li a7, SYS_exit
        ecall
        jal exit

# char init[] = &quot;/init\0&quot;;
init:
  .string &quot;/init\0&quot;

# char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0

</code></pre>
<p><code>initcode.s</code> (<code>user/initcode.S</code>) loads the number for the <code>exec</code> system call, <code>SYS_EXEC</code> into register <code>a7</code>, and then calls <code>ecall</code> to re-enter the kernel in order to execute <code>exec</code> system call. The details of this procedure is what we will discuss in detail later on.</p>
<p>After the kernel has completed <code>exec</code> by replacing the page table and registers of the current process. it return to user space in the <code>/init</code> process (execute it). <strong><code>init</code></strong> creates a new <a href="https://en.wikipedia.org/wiki/System_console">console device file</a> (console is the text entry and display device for system administration messages) and then opens it as file descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.</p>
<pre><code class="language-c">// init.c
// init: The initial user-level program

char *argv[] = { &quot;sh&quot;, 0 };

int
main(void)
{
  int pid, wpid;

  if(open(&quot;console&quot;, O_RDWR) &lt; 0){
    mknod(&quot;console&quot;, CONSOLE, 0);
    open(&quot;console&quot;, O_RDWR);
  }
  dup(0);  // stdout
  dup(0);  // stderr

  for(;;){
    printf(&quot;init: starting sh\n&quot;);
    pid = fork();
    if(pid &lt; 0){
      printf(&quot;init: fork failed\n&quot;);
      exit(1);
    }
    if(pid == 0){
      exec(&quot;sh&quot;, argv);
      printf(&quot;init: exec sh failed\n&quot;);
      exit(1);
    }

    for(;;){
      // this call to wait() returns if the shell exits,
      // or if a parentless process exits.
      wpid = wait((int *) 0);
      if(wpid == pid){
        // the shell exited; restart it.
        break;
      } else if(wpid &lt; 0){
        printf(&quot;init: wait returned an error\n&quot;);
        exit(1);
      } else {
        // it was a parentless process; do nothing.
      }
    }
  }
}

</code></pre>
<h2>1. ecall</h2>
<h3>i. User-level process</h3>
<p><strong>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks and pipe buffers.</strong> xv6 uses the physical memory between the end of the kernel and <code>PHYSTOP</code> for run-time allocation, as we can see in the layout figure (va &amp; pa) located near the begin of this note, these area are not the part of <strong>direct mapping</strong>.</p>
<p>Each process has a separate page table. the figure below shows the layout of the <strong>user memory</strong> of an executing process in xv6. Notice that the stack is a single page, and is shown with the initial contents as created by <code>exec</code>, where contains the command-line arguments, as well as an array of pointers at the very top of the stack.</p>
<p><img src="Sources/procmem.png" alt="procmem"></p>
<h3>ii. RISC-V trap machinery</h3>
<p><strong>Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occured.</strong> Here is an outline of the most important registers: <strong><code>$sscratch</code></strong>, <strong><code>$stvec</code></strong> and <strong><code>$sepc</code></strong>:</p>
<p><img src="Sources/trapecall.png" alt="trapecall"></p>
<h3>iii. Traps from user space</h3>
<p><strong>After <code>init</code> starts the shell, the shell (<code>user/sh.c</code>) will call <code>getcmd</code> and trying to receive a command from user. <code>getcmd</code> will call <code>fprintf</code> defined in <code>user/printf.c</code> in order to print <code>$</code> at the console.</strong></p>
<p><strong>If you jump into the <code>fprintf</code> code located in <code>user/printf.c</code>, since the shell runs in the user-space, it require a <code>write</code> system call in order to print anything to the console.</strong></p>
<pre><code class="language-c">// user/printf.c
static void
putc(int fd, char c)
{
  write(fd, &amp;c, 1);
}
</code></pre>
<p><strong>After calling that <code>write</code> in user space, the <code>write</code> function which sit in the shell library will cause a trap:</strong></p>
<pre><code class="language-assembly"># user/sh.asm
0000000000000de8 &lt;write&gt;:
.global write
write:
 li a7, SYS_write
     de8:	48c1                	li	a7,16
 ecall
     dea:	00000073          	ecall
 ret
     dee:	8082                	ret
</code></pre>
<p>A trap may occur while executing in user space if the user program makes a system call (<code>ecall</code> instruction).
<strong>And the <code>ecall</code> basically did three things:</strong></p>
<ol>
<li><strong>Change mode from user to supervisor.</strong></li>
<li><strong>Save <code>$pc</code> in <code>$sepc</code>.</strong></li>
<li><strong>Jump to <code>$stvec</code>.</strong></li>
</ol>
<p><strong>Now lets jump into the runtime of shell when it prints <code>$</code> which causes the <code>write</code> system call for the first time:</strong></p>
<pre><code>(gdb) b *0xdea
Breakpoint 1 at 0xdea
(gdb) c
Continuing.

Breakpoint 1, 0x0000000000000dea in ?? ()
=&gt; 0x0000000000000dea:  73 00 00 00     ecall
(gdb) x/3i 0xde8
   0xde8:       li      a7,16
=&gt; 0xdea:       ecall
   0xdee:       ret
</code></pre>
<p><strong>And we can check the current <code>$pc</code> and page table of our shell process:</strong></p>
<pre><code>(gdb) print $pc
$1 = (void (*)()) 0xdea

(qemu) info mem
vaddr            paddr            size             attr
---------------- ---------------- ---------------- -------
0000000000000000 0000000087f61000 0000000000001000 rwxu-a-
0000000000001000 0000000087f5e000 0000000000001000 rwxu-a-
0000000000002000 0000000087f5d000 0000000000001000 rwx----
0000000000003000 0000000087f5c000 0000000000001000 rwxu-ad
0000003fffffe000 0000000087f70000 0000000000001000 rw---ad
0000003ffffff000 0000000080007000 0000000000001000 r-x--a-
</code></pre>
<p><strong>As you can see that, this is a very small page table that contains only six mappings, if you check that user-level process memory layout figure above, from top to bottom:</strong></p>
<ul>
<li><strong><code>0x0000000000000000</code> to <code>0x0000000000001000</code> refers to the shell's instructions (text).</strong></li>
<li><strong><code>0x0000000000001000</code> to <code>0x0000000000002000</code> refers to the shell's data.</strong></li>
<li><strong><code>0x0000000000002000</code> to <code>0x0000000000003000</code> refers to the stack guard page</strong>
<ul>
<li>which is invalid, since it doesn't have the <code>u</code> flag set.</li>
<li>the user code can only get at pte entries for which the <code>u</code> flag is set.</li>
</ul>
</li>
<li><strong><code>0x0000000000003000</code> to <code>0x0000000000004000</code> refers to the stack page, which can grow dynamically.</strong></li>
<li><strong><code>0x0000003fffffe000</code> to <code>0x0000003ffffff000</code> refers to the trap frame page.</strong></li>
<li><strong><code>0x0000003ffffff000</code> to <code>0x0000004000000000</code> refers to the trampoline page.</strong></li>
</ul>
<p><strong>Now let's step further, and execute that <code>ecall</code> instruction:</strong></p>
<pre><code>(gdb) stepi
0x0000003ffffff000 in ?? ()
=&gt; 0x0000003ffffff000:  73 15 05 14     csrrw   a0,sscratch,a0
(gdb) print $pc
$2 = (void (*)()) 0x3ffffff000
(gdb) x/6i 0x3ffffff000
=&gt; 0x3ffffff000:        csrrw   a0,sscratch,a0
   0x3ffffff004:        sd      ra,40(a0)
   0x3ffffff008:        sd      sp,48(a0)
   0x3ffffff00c:        sd      gp,56(a0)
   0x3ffffff010:        sd      tp,64(a0)
   0x3ffffff014:        sd      t0,72(a0)
</code></pre>
<p><strong>As we can see, the value <code>$stvec</code> register is the current <code>$pc</code> register value, which is the begining of trampoline page. And that is the reason why we ended up executing at this particular place.</strong></p>
<pre><code>(gdb) print/x $stvec
$4 = 0x3ffffff000
(gdb) print/x $sepc
$5 = 0xdea
(gdb) print/x $sscratch
$6 = 0x3fffffe000
</code></pre>
<p><strong>Another thing is we can see is that the <code>ecall</code> hardware instruction has already helped us storing the previous <code>$pc</code> into <code>$sepc</code>.</strong></p>
<h2>2. Trampoline</h2>
<p><strong>We're now executing in the &quot;trampoline&quot; page, which contains the start of the kernel's trap handling code</strong>, <code>ecall</code> does as little as possible to allow maximum flexibility to the operating system programmer to design the os however they like.</p>
<p>What need to happen now?</p>
<ul>
<li><strong>Save the 32 user register values.</strong> (so we can later restore them and when we want to resume the user code)
<ul>
<li>we need to save those registers because we are going to run C code inside kernel, which will use all these registers.</li>
</ul>
</li>
<li><strong>Switch to the kernel page table.</strong></li>
<li>Set up stack for kernel C code.</li>
<li>Jump to some sensible place in the C code in the kernel.</li>
</ul>
<h3>i. The Trap frame</h3>
<ul>
<li><strong>We don't even know the address of the kernel page table</strong></li>
<li>We need some spare registers in order to execute change <code>$satp</code> instruction.</li>
</ul>
<p><strong>The xv6 maps a page, called trapframe into every user page table, it has space to to hold the saved registers</strong>, the kernel gives each process a different trapframe page.</p>
<p>The virtual address of that trapframe is stored in the <strong><code>$sscrach</code></strong> register, and you can find the struct trapframe in <code>kernel/proc.h</code>.</p>
<pre><code class="language-c">// per-process data for the trap handling code in trampoline.S.
// sits in a page by itself just under the trampoline page in the
// user page table. not specially mapped in the kernel page table.
// the sscratch register points here.
// uservec in trampoline.S saves user registers in the trapframe,
// then initializes registers from the trapframe's
// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.
// usertrapret() and userret in trampoline.S set up
// the trapframe's kernel_*, restore user registers from the
// trapframe, switch to the user page table, and enter user space.
// the trapframe includes callee-saved user registers like s0-s11 because the
// return-to-user path via usertrapret() doesn't return through
// the entire kernel call stack.
struct trapframe {
  /*   0 */ uint64 kernel_satp;   // kernel page table
  /*   8 */ uint64 kernel_sp;     // top of process's kernel stack
  /*  16 */ uint64 kernel_trap;   // usertrap()
  /*  24 */ uint64 epc;           // saved user program counter
  /*  32 */ uint64 kernel_hartid; // saved kernel tp
  /*  40 */ uint64 ra;
  /*  48 */ uint64 sp;
  /*  56 */ uint64 gp;
  /*  64 */ uint64 tp;
  /*  72 */ uint64 t0;
  /*  80 */ uint64 t1;
  /*  88 */ uint64 t2;
  /*  96 */ uint64 s0;
  /* 104 */ uint64 s1;
  /* 112 */ uint64 a0;
  /* 120 */ uint64 a1;
  /* 128 */ uint64 a2;
  /* 136 */ uint64 a3;
  /* 144 */ uint64 a4;
  /* 152 */ uint64 a5;
  /* 160 */ uint64 a6;
  /* 168 */ uint64 a7;
  /* 176 */ uint64 s2;
  /* 184 */ uint64 s3;
  /* 192 */ uint64 s4;
  /* 200 */ uint64 s5;
  /* 208 */ uint64 s6;
  /* 216 */ uint64 s7;
  /* 224 */ uint64 s8;
  /* 232 */ uint64 s9;
  /* 240 */ uint64 s10;
  /* 248 */ uint64 s11;
  /* 256 */ uint64 t3;
  /* 264 */ uint64 t4;
  /* 272 */ uint64 t5;
  /* 280 */ uint64 t6;
};

</code></pre>
<h3>ii. The Trampoline</h3>
<p><img src="Sources/trampoline.png" alt="trampoline"></p>
<p><strong>After <code>ecall</code>, as we mentioned before, the hardware set <code>$pc</code> to <code>$stvec</code>, which is the begining of the trapoline page</strong>.</p>
<p>The first instruction, <code>csrrw</code>. swap <code>$a0</code> register and <code>$sscratch</code>, as we can see, after executing this very first instruction, the <code>$a0</code> becomes <code>0x3fffffe000</code>, which is the begining of the trap page. And <code>$sscratch</code> is 2, which is the first argument of this <code>write</code> system call -- the file descriptor <code>2</code>.</p>
<pre><code>(gdb) print/x $a0 
$1 = 0x3fffffe000

(gdb) print $sscratch
$2 = 2
</code></pre>
<p>The very next 32 <code>sd</code> instructions in this trampoline code, store every 64-bit register to a different offset in the trap frame page.</p>
<pre><code class="language-assembly">.globl trampoline
trampoline:
.align 4
.globl uservec
uservec:    
	#
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.
        #
        # sscratch points to where the process's p-&gt;trapframe is
        # mapped into user space, at TRAPFRAME.
        #
        
	# swap a0 and sscratch
        # so that a0 is TRAPFRAME
        csrrw a0, sscratch, a0

        # save the user registers in TRAPFRAME
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0)
        sd t1, 80(a0)
        sd t2, 88(a0)
        sd s0, 96(a0)
        sd s1, 104(a0)
        sd a1, 120(a0)
        sd a2, 128(a0)
        sd a3, 136(a0)
        sd a4, 144(a0)
        sd a5, 152(a0)
        sd a6, 160(a0)
        sd a7, 168(a0)
        sd s2, 176(a0)
        sd s3, 184(a0)
        sd s4, 192(a0)
        sd s5, 200(a0)
        sd s6, 208(a0)
        sd s7, 216(a0)
        sd s8, 224(a0)
        sd s9, 232(a0)
        sd s10, 240(a0)
        sd s11, 248(a0)
        sd t3, 256(a0)
        sd t4, 264(a0)
        sd t5, 272(a0)
        sd t6, 280(a0)

	# save the user a0 in p-&gt;trapframe-&gt;a0
        csrr t0, sscratch
        sd t0, 112(a0)

        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp
        ld sp, 8(a0)

        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid
        ld tp, 32(a0)

        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap
        ld t0, 16(a0)

        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp
        ld t1, 0(a0)
        csrw satp, t1
        sfence.vma zero, zero

        # a0 is no longer valid, since the kernel page
        # table does not specially map p-&gt;tf.

        # jump to usertrap(), which does not return
        jr t0
</code></pre>
<p>After save those 32 general-purpose registers, we need to restore some important register by execute <code>ld</code> instrucions, which will be used in the kernel space later on.</p>
<h4>Process's kernel stack pointer</h4>
<pre><code>(gdb) print/x $sp
$5 = 0x3fffffc000
</code></pre>
<p>The process's kernel stack is up in high memory, because xv6 treats kernel stack especially so that it can put a guard page under each kernel stack.</p>
<h4>Process's current core</h4>
<pre><code>(gdb) print/x $tp
$6 = 0x0
</code></pre>
<p>Since there is no direct way in RISC-V to figure out which of the multiple cores you're running on, xv6 actually keeps the core number called <code>kernel_hartid</code> in the <code>$tp</code> register.</p>
<h4>User trap</h4>
<pre><code>(gdb) print/x $t0
$7 = 0x80001c38
</code></pre>
<p>Then we load the user trap c function address into <code>$t0</code>, which we'll jump to that location later on.</p>
<h4>Kernel page table</h4>
<pre><code>(gdb) print/x $satp
$8 = 0x8000000000087fff
</code></pre>
<p><strong>As soon as the <code>ld</code> and <code>csrw</code> instruction executes, we'll switch page table from the user page table to kernel page table, after these instructions finished, we can see now we are in the kernel page table</strong>. And now we are pretty much ready to execute c code in the kernel.</p>
<pre><code>(qemu) info mem
vaddr            paddr            size             attr
---------------- ---------------- ---------------- -------
000000000c000000 000000000c000000 0000000000001000 rw---ad
000000000c001000 000000000c001000 0000000000001000 rw-----
000000000c002000 000000000c002000 0000000000001000 rw---ad
000000000c003000 000000000c003000 00000000001fe000 rw-----
000000000c201000 000000000c201000 0000000000001000 rw---ad
000000000c202000 000000000c202000 00000000001fe000 rw-----
0000000010000000 0000000010000000 0000000000002000 rw---ad
0000000080000000 0000000080000000 0000000000007000 r-x--a-
0000000080007000 0000000080007000 0000000000001000 r-x----
0000000080008000 0000000080008000 0000000000012000 rw---ad
000000008001a000 000000008001a000 0000000000001000 rw-----
000000008001b000 000000008001b000 0000000000005000 rw---ad
0000000080020000 0000000080020000 0000000000006000 rw-----
0000000080026000 0000000080026000 0000000000001000 rw---ad
0000000080027000 0000000080027000 0000000007f35000 rw-----
0000000087f5c000 0000000087f5c000 000000000001c000 rw---ad
0000000087f78000 0000000087f78000 0000000000088000 rw-----
0000003ffff7f000 0000000087f78000 000000000003e000 rw-----
0000003fffffb000 0000000087fb6000 0000000000002000 rw---ad
0000003ffffff000 0000000080007000 0000000000001000 r-x--a-
</code></pre>
<p><strong>Note that we just switched the page table while executing the code in trampoline page, you may wonder that why isn't there a crash at this point.</strong>
<strong>The reason is that both kernel page table and user page table maps the trampoline page (same va) into same pa. (bottom of two page tables, both of them maps <code>0x0000003ffffff000</code> into <code>0x0000000080007000</code>)</strong></p>
<h2>3. usertrap</h2>
<p><strong>After the last <code>jr t0</code> instruction in trampoline, we are now in the <code>usertrap</code> c code in the kernel.</strong></p>
<pre><code class="language-c">// kernel/trap.c
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() &amp; SSTATUS_SPP) != 0)
    panic(&quot;usertrap: not from user mode&quot;);

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p-&gt;trapframe-&gt;epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(p-&gt;killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p-&gt;trapframe-&gt;epc += 4;

    // an interrupt will change sstatus &amp;c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf(&quot;usertrap(): unexpected scause %p pid=%d\n&quot;, r_scause(), p-&gt;pid);
    printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());
    p-&gt;killed = 1;
  }

  if(p-&gt;killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
</code></pre>
<h3>i. Switch to kernel trap handler</h3>
<pre><code class="language-c">  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);
</code></pre>
<p>The way xv6 handles traps is different depending on whether they come from user space or from the kernel. Since we are now in the kernel space, we change the <code>stvec</code> to point to this <code>kernelvec</code> which is the kernel trap handler rather than current user trap handler.</p>
<h3>ii. Figure out current running process</h3>
<pre><code class="language-c">  struct proc *p = myproc();
</code></pre>
<p>We need to figure out what process we're running by calling that <strong><code>myproc</code></strong> function. <strong><code>myproc</code></strong> actually use the current cpu id by read the <code>$tp</code> which we set in trampoline page, to index the current process id.</p>
<h3>iii. Save the user program counter</h3>
<pre><code class="language-c">  p-&gt;trapframe-&gt;epc = r_sepc();
</code></pre>
<p>As we can see in <strong><code>ecall</code></strong> the saved user pc is still sitting there in <code>$sepc</code>, but one of the thing that could happen while we are in the kernel is that we might switch to another process. And that process might going to that process'user space and may make a system call which causes <code>$sepc</code> to be overwritten. <strong>We have to save our <code>$sepc</code> in some memory associate with this process.</strong></p>
<h3>iv. Figure out why we came here</h3>
<pre><code class="language-c">  if(r_scause() == 8){
    // system call

    if(p-&gt;killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p-&gt;trapframe-&gt;epc += 4;

    // an interrupt will change sstatus &amp;c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
</code></pre>
<p><strong>When <code>ecall</code> being executed, despite the 3 most important instructions, actually the machine will set <code>$scause</code> to reflect the trap's cause.</strong>
If <code>$scause</code> is equal to 8, which means we came here because of a system call, so we're gonna execute this if statement.</p>
<p>After we set the <code>pc+4</code>, which make sure that after the whole system call return, we will resume our user code, and enable interrupts. We are now in the entry of the system call handler -&gt; <strong><code>syscall</code></strong>.</p>
<h2>4. syscall</h2>
<pre><code class="language-c">// kernel/syscall.c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p-&gt;trapframe-&gt;a7;
  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
    p-&gt;trapframe-&gt;a0 = syscalls[num]();
  } else {
    printf(&quot;%d %s: unknown sys call %d\n&quot;,
            p-&gt;pid, p-&gt;name, num);
    p-&gt;trapframe-&gt;a0 = -1;
  }
}
</code></pre>
<p><strong>The <code>syscall</code> function is simple, after get current process, it just retrieves that <code>$a7</code> register which we was saved away in the trap frame by the trampoline code. And then indexes into that syscalls table, and then calls that function.</strong> And the return value of that syscall function is stored in register <code>$a0</code> of that trap frame.</p>
<pre><code>(gdb) stepi
sys_write () at kernel/sysfile.c:83
</code></pre>
<p>If we use gdb to step into that function, now we are in <strong><code>sys_write</code></strong>, which is the kernel implementation of the <code>write</code> system call.</p>
<pre><code class="language-c">// kernel/sysfile.c
uint64
sys_write(void)
{
  struct file *f;
  int n;
  uint64 p;

  if(argfd(0, 0, &amp;f) &lt; 0 || argint(2, &amp;n) &lt; 0 || argaddr(1, &amp;p) &lt; 0)
    return -1;

  return filewrite(f, p, n);
}
</code></pre>
<p>Since we are now only interested in getting into and out of the kernel, we are going to step over the actual implementation of system call.</p>
<h2>5. usertrapret</h2>
<pre><code class="language-c">// kernel/trap.c
void
usertrapret(void)
{
  struct proc *p = myproc();

  // we're about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we're back in user space, where usertrap() is correct.
  intr_off();

  // send syscalls, interrupts, and exceptions to trampoline.S
  w_stvec(TRAMPOLINE + (uservec - trampoline));

  // set up trapframe values that uservec will need when
  // the process next re-enters the kernel.
  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table
  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process's kernel stack
  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;
  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()

  // set up the registers that trampoline.S's sret will use
  // to get to user space.
  
  // set S Previous Privilege mode to User.
  unsigned long x = r_sstatus();
  x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode
  x |= SSTATUS_SPIE; // enable interrupts in user mode
  w_sstatus(x);

  // set S Exception Program Counter to the saved user pc.
  w_sepc(p-&gt;trapframe-&gt;epc);

  // tell trampoline.S the user page table to switch to.
  uint64 satp = MAKE_SATP(p-&gt;pagetable);

  // jump to trampoline.S at the top of memory, which 
  // switches to the user page table, restores user registers,
  // and switches to user mode with sret.
  uint64 fn = TRAMPOLINE + (userret - trampoline);
  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
}
</code></pre>
<h3>i. Change stvec to the user trap handler</h3>
<pre><code class="language-c">  // send syscalls, interrupts, and exceptions to trampoline.S
  w_stvec(TRAMPOLINE + (uservec - trampoline));
</code></pre>
<p>The reason we turn off interrupts because once we changed the user trap handler, we're still executing in the kernel, and if an interrupt occur then it would go to the user trap handler even though we're executing in the kernel.</p>
<h3>ii. Prepare the trap frame for the next kernel re-entering</h3>
<pre><code class="language-c">  // set up trapframe values that uservec will need when
  // the process next re-enters the kernel.
  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table
  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process's kernel stack
  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;
  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()
</code></pre>
<h3>iii. Ready to execute the userret asm code in <code>trampoline.s</code></h3>
<pre><code class="language-c">  // set S Exception Program Counter to the saved user pc.
  w_sepc(p-&gt;trapframe-&gt;epc);

  // tell trampoline.S the user page table to switch to.
  uint64 satp = MAKE_SATP(p-&gt;pagetable);

  // jump to trampoline.S at the top of memory, which 
  // switches to the user page table, restores user registers,
  // and switches to user mode with sret.
  uint64 fn = TRAMPOLINE + (userret - trampoline);
  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
</code></pre>
<ul>
<li>Write the resume user-code pc which located in <code>$epc</code> to the <code>$satp</code> so that the <strong><code>sret</code></strong> instruction can assign that value into pc when switching to the user space.</li>
<li>Cook up the <code>$satp</code>, which will be used in the trampoline code later.</li>
<li>Get the location of <strong><code>userret</code></strong> in trampoline.s, and then call that function with the <code>TRAPFRAME</code> and <code>satp</code> arguments passing.</li>
</ul>
<h2>6. userret</h2>
<pre><code>.globl userret
userret:
        # userret(TRAPFRAME, pagetable)
        # switch from kernel to user.
        # usertrapret() calls here.
        # a0: TRAPFRAME, in user page table.
        # a1: user page table, for satp.

        # switch to the user page table.
        csrw satp, a1
        sfence.vma zero, zero

        # put the saved user a0 in sscratch, so we
        # can swap it with our a0 (TRAPFRAME) in the last step.
        ld t0, 112(a0)
        csrw sscratch, t0

        # restore all but a0 from TRAPFRAME
        ld ra, 40(a0)
        ld sp, 48(a0)
        ld gp, 56(a0)
        ld tp, 64(a0)
        ld t0, 72(a0)
        ld t1, 80(a0)
        ld t2, 88(a0)
        ld s0, 96(a0)
        ld s1, 104(a0)
        ld a1, 120(a0)
        ld a2, 128(a0)
        ld a3, 136(a0)
        ld a4, 144(a0)
        ld a5, 152(a0)
        ld a6, 160(a0)
        ld a7, 168(a0)
        ld s2, 176(a0)
        ld s3, 184(a0)
        ld s4, 192(a0)
        ld s5, 200(a0)
        ld s6, 208(a0)
        ld s7, 216(a0)
        ld s8, 224(a0)
        ld s9, 232(a0)
        ld s10, 240(a0)
        ld s11, 248(a0)
        ld t3, 256(a0)
        ld t4, 264(a0)
        ld t5, 272(a0)
        ld t6, 280(a0)

	# restore user a0, and save TRAPFRAME in sscratch
        csrrw a0, sscratch, a0
        
        # return to user mode and user pc.
        # usertrapret() set up sstatus and sepc.
        sret
</code></pre>
<p>After the first instruction, as we can see, now we are in the much smaller user page table but luckily still with the trampoline page map so we don't crash on the next instruction.</p>
<pre><code>(qemu) info mem
vaddr            paddr            size             attr
---------------- ---------------- ---------------- -------
0000000000000000 0000000087f61000 0000000000001000 rwxu-a-
0000000000001000 0000000087f5e000 0000000000001000 rwxu-a-
0000000000002000 0000000087f5d000 0000000000001000 rwx----
0000000000003000 0000000087f5c000 0000000000001000 rwxu-ad
0000003fffffe000 0000000087f70000 0000000000001000 rw---ad
0000003ffffff000 0000000080007000 0000000000001000 r-x--a-
</code></pre>
<p>Back to <strong>4.syscall</strong>, when we are executing the <strong><code>syscall</code></strong>, we store the return value into <code>p-&gt;trapframe-&gt;a0</code>.
<strong>Since the current value of <code>$a0</code> is the <code>TRAPFRAME</code> address, we cannot overwrite it, until we restore all saved registers. So we load the <code>p-&gt;trapframe-&gt;a0</code> into <code>$t0</code>, and then swap it with <code>$sscratch</code>.</strong></p>
<pre><code>(gdb) print/x $a0
$9 = 0x3fffffe000
(gdb) print/x $sscratch
$10 = 0x1
</code></pre>
<p><strong>After that, we restore all registers but <code>$a0</code> from <code>TRAPFRAME</code>, finally, we swap <code>$sscratch</code> and <code>$a0</code> both restore the correct return value of <code>syscall</code> and load the <code>TRAPFRAME</code> into <code>$sscratch</code>, so that the trap handling code that we talked about before will be able to use that <code>$sscratch</code> to get at the trap frame.</strong></p>
<pre><code>(gdb) print/x $sscratch
$11 = 0x3fffffe000
</code></pre>
<pre><code>ra             0xe82    0xe82
sp             0x3e90   0x3e90
gp             0x505050505050505        0x505050505050505
tp             0x505050505050505        0x505050505050505
t0             0x505050505050505        361700864190383365
t1             0x505050505050505        361700864190383365
t2             0x505050505050505        361700864190383365
fp             0x3eb0   0x3eb0
s1             0x12e1   4833
a0             0x1      1
a1             0x3e9f   16031
a2             0x1      1
a3             0x505050505050505        361700864190383365
a4             0x505050505050505        361700864190383365
a5             0x2      2
a6             0x505050505050505        361700864190383365
a7             0x10     16
s2             0x24     36
s3             0x0      0
s4             0x25     37
s5             0x2      2
s6             0x3f50   16208
s7             0x1480   5248
s8             0x15     21
s9             0x1428   5160
s10            0x10     16
s11            0x28     40
t3             0x505050505050505        361700864190383365
t4             0x505050505050505        361700864190383365
t5             0x505050505050505        361700864190383365
t6             0x505050505050505        361700864190383365
pc             0x3ffffff10e     0x3ffffff10e
</code></pre>
<p><strong>Now all these 32 general-purpose registers happen to be the same set of registers before we make that system call in user space. We are now ready to jump back to user code and resume the procedure after system call.</strong></p>
<h2>7. sret</h2>
<p><strong>Same as <code>ecall</code>, the <code>sret</code> instruction does many things for us.</strong></p>
<ol>
<li><strong>Switch to user mode.</strong></li>
<li><strong>Copy <code>$sepc</code> to <code>$pc</code>.</strong></li>
</ol>
<pre><code>(gdb) stepi
0x0000000000000dee in ?? ()
=&gt; 0x0000000000000dee:  82 80   ret
(gdb) print/x $pc
$12 = 0xdee
</code></pre>
<p>Now we are back to the shell, just at the very next instruction of <strong><code>ecall</code>.</strong> And that is the whole procedure of a <strong>Trap.</strong></p>
<p><img src="Sources/traps.png" alt="traps"></p>
<h2>8. Summary</h2>
<p><strong>To wrap up, the system calls are sort of look like function calls but the user-kernel transitions are much more complex than normal function calls are.</strong></p>
<p><strong>A lot of the complexities due to the requirement for isolation, because the kernel just can't trust anything in user space, that makes many instructions cannot be executed in user space.</strong></p>
	</section>
	</div>
    </div>

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
this.page.url = "https://angold4.org/os/docs/lectures/3Traps.html"
this.page.identifier = "os/docs/lectures/3Traps.html"

    };
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://angold.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>
<footer>
   <div class="well well-lg" id="footer-well">
      <div class="container">


      <div class="row">
         <div class="col-xs-6">
            <a href="https://angold4.org" title="Angold-4 Organization" class="image-link"><img src="../../../images/logo.png" class="cmudb-logo" /></a>
         </div>
         <div class="col-xs-6">
            <p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p>
        </div>
      </div>
   </div>
   </div>
</footer>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../../theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="../../../theme/js/respond.min.js"></script>

<!-- Fix scrolling issues to internal HREFs that get positioned behind navbar -->
<!-- http://stackoverflow.com/questions/10732690/offsetting-an-html-anchor-to-adjust-for-fixed-header -->
<script src="../../../theme/js/href_scroll.js"></script>

<!-- You know what this is and you know what he did to me... -->
<script src="../../../theme/js/tim-kraska-betrayed-me.js"></script>
</body>
</html>

